#!/usr/bin/env python
#
# Copyright 2018 Kenneth A. Giusti
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#


import logging
import sys
import time
import uuid

from oslo_config import cfg
from oslo_messaging.opts import list_opts
import oslo_messaging as messaging

#
# A simple RPC Server
#

LOG = logging.getLogger()

_options = [
    cfg.StrOpt('name',
               help='Name of this server (used for direct addressing)'),
    cfg.StrOpt("url",
               help="transport address, defaults to 'rabbit://localhost:5672'"),
    cfg.StrOpt('topic',
               default='my-topic',
               help="target topic, default 'my-topic'"),
    cfg.StrOpt('exchange',
               default="my-exchange",
               help="target exchange, default 'my-exchange'"),
    cfg.StrOpt('namespace',
               help="target namespace, default None"),
    cfg.StrOpt("target_version",
               help="Override the default version in the target address"),
    cfg.BoolOpt("debug",
                default=False,
                help="Enabled debug logging"),
    cfg.StrOpt('executor',
               default='threading',
               help='threading model to use when dispatching calls')
]


class TestEndpoint(object):
    """
    A simple server endpoint
    """
    def __init__(self, server, target=None):
        self.server = server
        self.target = target
        self.calls = 0

    def sink(self, ctx, **args):
        """
        A cast (or fanout) call - no reply
        """
        logging.debug("%s::TestEndpoint:sink( ctxt=%s arg=%s ) called!!!",
                      self.server, str(ctx), str(args))
        self.calls += 1

    def echo(self, ctx, **args):
        """
        Send the args back to the sender
        """
        logging.debug("%s::TestEndpoint::echo( ctxt=%s arg=%s ) called!!!",
                      self.server, str(ctx), str(args))
        self.calls += 1
        return {"method":"echo", "context":ctx, "args":args}

    def sleep(self, ctx, **args):
        """
        For testing oslo.messaging:
        sleep for 'timeout' value in args, or 10 seconds
        """
        logging.debug("%s::TestEndpoint::sleeps( ctxt=%s arg=%s ) called!!!",
                      self.server, str(ctx), str(args))
        time.sleep(float(args.get("timeout", 10.0)))
        self.calls += 1
        return args.get("reply")

    def fail(self, ctx, **args):
        """
        For testing oslo.messaging:
        Throw an exception during call processing
        """
        logging("%s::TestEndpoint::fail( ctxt=%s arg=%s ) called!!!"
                  % (self.server, str(ctx),str(args)))
        self.calls += 1
        raise RuntimeError("fail method invoked!")


def main(argv=None):

    conf = cfg.CONF
    conf.register_cli_opts(_options)
    for group, options in list_opts():
        conf.register_opts(options, group=group)

    conf(sys.argv[1:])

    server_name = conf.name or uuid.uuid4().hex
    url = conf.url or conf.transport_url
    level = logging.DEBUG if conf.debug else logging.INFO
    logging.basicConfig(level=level)

    transport = messaging.get_rpc_transport(conf, url=url)

    target = messaging.Target(exchange=conf.exchange,
                              topic=conf.topic,
                              namespace=conf.namespace,
                              server=server_name,
                              version=conf.target_version)
    endpoint = TestEndpoint(server_name, target)
    server = messaging.get_rpc_server(transport, target,
                                      [endpoint],
                                      executor=conf.executor)

    server.start()
    print("Server %s running" % server_name)
    try:
        while True:
            time.sleep(10)
    except KeyboardInterrupt:
        print("Stopping...")
        server.stop()
        server.wait()
    print("%d calls processed" % endpoint.calls)
    return 0

if __name__ == "__main__":
    sys.exit(main())
