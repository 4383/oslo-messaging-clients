#!/usr/bin/env python
#
# Copyright 2018 Kenneth A. Giusti
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

import logging
import sys
import threading
import time

from oslo_config import cfg
from oslo_messaging.opts import list_opts
import oslo_messaging as messaging

#
# A simple RPC Client
#


_options = [
    cfg.StrOpt("method",
               default="echo",
               help="The name of the method to call on the server"),
    cfg.StrOpt("kwargs",
               default="name=echo",
               help="Method arguments in the form 'name=value ...'"),
    cfg.StrOpt("url",
               help="transport address, default 'rabbit://localhost:5672'"),
    cfg.StrOpt("server",
               help="Send only to the named server"),
    cfg.StrOpt("topic",
               default="my-topic",
               help="target topic, default 'my-topic'"),
    cfg.StrOpt('exchange',
               default="my-exchange",
               help="target exchange, default 'my-exchange'"),
    cfg.StrOpt('namespace',
               help="target namespace, default None"),
    cfg.StrOpt("target_version",
               help="Override the default version in the target address"),
    cfg.IntOpt("timeout",
               default=60,
               help="timeout RPC request in seconds, default 60"),
    cfg.BoolOpt("fanout",
                default=False,
                help="Send RPC fanout cast"),
    cfg.BoolOpt("cast",
                default=False,
                help="Send RPC cast"),
    cfg.IntOpt("repeat",
               default=1,
               help="Repeat the request N times per thread (0=forever)"),
    cfg.BoolOpt("stats",
                default=False,
                help="Calculate throughput"),
    cfg.BoolOpt("debug",
                default=False,
                help="Enable debug logging")
]


class ClientThread(threading.Thread):
    def __init__(self, conf, transport, target, method, kwargs):
        super(ClientThread, self).__init__()
        self.transport = transport
        self.target = target
        self.conf = conf
        self.method = method
        self.kwargs = kwargs
        self.daemon = True
        self.start()

    def run(self):
        conf = self.conf


def main(argv=None):
    conf = cfg.CONF
    conf.register_cli_opts(_options)
    for group, options in list_opts():
        conf.register_opts(options, group=group)

    conf(sys.argv[1:])

    level = logging.DEBUG if conf.debug else logging.INFO
    logging.basicConfig(level=level)

    url = conf.url or conf.transport_url
    args = conf.kwargs.split() if conf.kwargs else []
    kwargs = dict([(x.split('=')[0], x.split('=')[1] if len(x) > 1 else None)
                   for x in args])

    logging.debug("Calling %s (%s)%s%s%s...", conf.method, kwargs,
                  (" [server=%s]" % conf.server) if conf.server else "",
                  " [fanout]" if conf.fanout else "",
                  " [cast]" if conf.cast else "")

    if hasattr(messaging, "get_rpc_transport"):
        transport = messaging.get_rpc_transport(conf, url=url)
    else:
        transport = messaging.get_transport(conf, url=url)

    target = messaging.Target(exchange=conf.exchange,
                              topic=conf.topic,
                              namespace=conf.namespace,
                              server=conf.server,
                              fanout=conf.fanout,
                              version=conf.target_version)
    client = messaging.RPCClient(transport,
                                 target,
                                 timeout=conf.timeout,
                                 version_cap=conf.target_version).prepare()
    test_context = {"application": "rpc-client", "time": time.ctime()}

    start_time = time.time()
    repeat = 0
    try:
        while conf.repeat == 0 or repeat < conf.repeat:
            try:
                if conf.cast or conf.fanout:
                    client.cast(test_context, conf.method, **kwargs)
                else:
                    rc = client.call(test_context, conf.method, **kwargs)
                    logging.debug("RPC return value=%s", str(rc))
            except Exception as e:
                LOG.error("Unexpected exception occured: %s" % str(e))
                break
            repeat += 1
    except KeyboardInterrupt:
        logging.debug("Stopping...")

    print("%d RPC call(s) complete" % conf.repeat)

    if conf.stats and repeat:
        delta = time.time() - start_time
        stats = (float(repeat)/float(delta)) if delta else 0
        print("Messages per second: %6.4f" % stats)

    logging.debug("RPC complete!  Cleaning up transport...")
    # Hack: the client does not block when casting or fanout so delay the
    # cleanup a bit in order for any buffered messages to be sent
    if conf.cast or conf.fanout:
        time.sleep(1.0)
    transport.cleanup()
    return 0

if __name__ == "__main__":
    sys.exit(main())
